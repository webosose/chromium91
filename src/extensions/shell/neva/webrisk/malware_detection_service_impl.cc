// Copyright 2022 LG Electronics, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

#include "extensions/shell/neva/webrisk/malware_detection_service_impl.h"

#include "base/base64.h"
#include "base/command_line.h"
#include "base/files/file_util.h"
#include "base/single_thread_task_runner.h"
#include "base/strings/string_number_conversions.h"
#include "base/time/time.h"
#include "content/public/browser/browser_context.h"
#include "content/public/browser/storage_partition.h"
#include "content/shell/common/shell_neva_switches.h"
#include "crypto/encryptor.h"
#include "crypto/sha2.h"
#include "crypto/symmetric_key.h"
#include "extensions/shell/common/switches.h"
#include "extensions/shell/neva/webrisk/core/webrisk_fetch_hashes.h"
#include "extensions/shell/neva/webrisk/core/webrisk_search_hashes.h"
#include "extensions/shell/neva/webrisk/core/webrisk_store.h"
#include "net/base/escape.h"
#include "net/http/http_status_code.h"
#include "net/traffic_annotation/network_traffic_annotation.h"
#include "net/url_request/redirect_info.h"
#include "services/network/public/cpp/resource_request.h"
#include "services/network/public/cpp/shared_url_loader_factory.h"
#include "services/network/public/cpp/simple_url_loader.h"
#include "url/gurl.h"
#include "url/url_util.h"

namespace neva {

scoped_refptr<MalwareDetectionService> MalwareDetectionService::Create() {
  return base::MakeRefCounted<webrisk::MalwareDetectionServiceImpl>();
}

}  // namespace neva


namespace webrisk {

namespace {

const uint32_t kCheckHashUpdateDelayMs = 200;

const char kWebRiskStoreFileName[] = "webrisk.store";
const char kGoogleAuthDecryptionKey[] = "google_auth_decryption_key";
const char kGoogleServiceAuthKey[] = "google_service_auth_key";
const char kInitializationVector[] = "0123456789ABCDEF";

std::string Unescape(const std::string& url) {
  std::string unescaped_str(url);
  const int kMaxLoopIterations = 1024;
  size_t old_size = 0;
  int loop_var = 0;
  do {
    old_size = unescaped_str.size();
    unescaped_str = net::UnescapeBinaryURLComponent(unescaped_str);
  } while (old_size != unescaped_str.size() &&
           ++loop_var <= kMaxLoopIterations);

  return unescaped_str;
}

std::string RemoveConsecutiveChars(const base::StringPiece str, const char c) {
  std::string output;
  // Output is at most the length of the original string.
  output.reserve(str.size());

  size_t i = 0;
  while (i < str.size()) {
    output.append(1, str[i++]);
    if (str[i - 1] == c) {
      while (i < str.size() && str[i] == c) {
        i++;
      }
    }
  }

  return output;
}

std::string Escape(const std::string& url) {
  std::string escaped_str;
  // The escaped string is larger so allocate double the length to reduce the
  // chance of the string being grown.
  escaped_str.reserve(url.length() * 2);
  const char* kHexString = "0123456789ABCDEF";
  for (size_t i = 0; i < url.length(); i++) {
    unsigned char c = static_cast<unsigned char>(url[i]);
    if (c <= ' ' || c > '~' || c == '#' || c == '%') {
      escaped_str += '%';
      escaped_str += kHexString[c >> 4];
      escaped_str += kHexString[c & 0xf];
    } else {
      escaped_str += c;
    }
  }

  return escaped_str;
}

void GenerateHostVariantsToCheck(const std::string& host,
                                 std::vector<std::string>* hosts) {
  hosts->clear();

  if (host.empty())
    return;

  const size_t kMaxHostsToCheck = 4;
  bool skipped_last_component = false;
  for (std::string::const_reverse_iterator i(host.rbegin());
       i != host.rend() && hosts->size() < kMaxHostsToCheck; ++i) {
    if (*i == '.') {
      if (skipped_last_component)
        hosts->push_back(std::string(i.base(), host.end()));
      else
        skipped_last_component = true;
    }
  }

  hosts->push_back(host);
}

void GeneratePathVariantsToCheck(const std::string& path,
                                 const std::string& query,
                                 std::vector<std::string>* paths) {
  paths->clear();
  if (path.empty())
    return;

  const size_t kMaxPathsToCheck = 4;
  for (std::string::const_iterator i(path.begin());
       i != path.end() && paths->size() < kMaxPathsToCheck; ++i) {
    if (*i == '/')
      paths->push_back(std::string(path.begin(), i + 1));
  }

  if (!paths->empty() && paths->back() != path)
    paths->push_back(path);

  if (!query.empty())
    paths->push_back(path + "?" + query);
}

}  // namespace

MalwareDetectionServiceImpl::MalwareDetectionServiceImpl()
    : malware_detection_thread_("MalwareDetectionThread") {}

MalwareDetectionServiceImpl::~MalwareDetectionServiceImpl() = default;

bool MalwareDetectionServiceImpl::Initialize(
    content::BrowserContext* browser_context) {
  if (initialize_state_ == kInProgress) {
    VLOG(2) << __func__ << " initialize in progress";
    return true;
  }

  if (google_service_auth_key_.empty()) {
    google_service_auth_key_ = GetGoogleServiceAuthKey();
    if (google_service_auth_key_.empty()) {
      initialize_state_ = kInvalidKey;
      LOG(ERROR) << __func__ << " Failed, WebRisk Service Key not valid !!";
      return false;
    }
  }

  if (!malware_detection_thread_.Start()) {
    initialize_state_ = kInitFailed;
    LOG(ERROR) << " malware detection thread failed to start";
    return false;
  }

  initialize_state_ = kInProgress;
  malware_detection_thread_.task_runner()->PostTask(
      FROM_HERE,
      base::BindOnce(&MalwareDetectionServiceImpl::InitializeTask,
                     base::Unretained(this), browser_context));
  return true;
}

const base::FilePath MalwareDetectionServiceImpl::GetFilePath(
    const char* file_name) {
  base::CommandLine* cmd_line = base::CommandLine::ForCurrentProcess();
  base::FilePath file_path(cmd_line->GetSwitchValuePath(switches::kUserDataDir)
                               .AppendASCII(file_name));
  return file_path;
}

const std::string MalwareDetectionServiceImpl::ReadDataFromFile(
    const char* file_name) {
  std::string data;
  if (!base::ReadFileToString(GetFilePath(file_name), &data)) {
    VLOG(2) << __func__ << " Failed to read from File !!";
    return {};
  }
  // Trim data for whitespaces, CR, LF
  return base::UTF16ToUTF8(
      base::TrimWhitespace(base::UTF8ToUTF16(data), base::TRIM_ALL));
}

const std::string MalwareDetectionServiceImpl::GetGoogleServiceAuthKey() {
  std::string decrypted_auth_key;
  // Read the AES128-CTR encryption key from file
  const std::string cipher_key = ReadDataFromFile(kGoogleAuthDecryptionKey);
  if (cipher_key.empty()) {
    LOG(ERROR) << __func__ << " Empty Cipher key !";
    return decrypted_auth_key;
  }

  // Read the encrypted google authentication key from file
  const std::string encrypted_key = ReadDataFromFile(kGoogleServiceAuthKey);
  if (encrypted_key.empty()) {
    LOG(ERROR) << __func__ << " Empty Google authentication key !";
    return decrypted_auth_key;
  }

  std::unique_ptr<crypto::SymmetricKey> key =
      crypto::SymmetricKey::Import(crypto::SymmetricKey::AES, cipher_key);
  if (!key) {
    LOG(ERROR) << __func__ << " Failed to import key for AES encryption.";
    return decrypted_auth_key;
  }

  crypto::Encryptor encryptor;
  if (!encryptor.Init(key.get(), crypto::Encryptor::CTR, "")) {
    LOG(ERROR) << __func__ << " Failed to initialize AES-CTR Encryptor.";
    return decrypted_auth_key;
  }

  if (!encryptor.SetCounter(kInitializationVector)) {
    LOG(ERROR) << __func__ << " Could not set counter block.";
    return decrypted_auth_key;
  }

  std::string b64_encrypted_key;
  base::Base64Decode(encrypted_key, &b64_encrypted_key);

  if (!encryptor.Decrypt(b64_encrypted_key, &decrypted_auth_key)) {
    LOG(ERROR) << __func__ << " Decryption Failed, Invalid key !!";
    return std::string();
  }

  return decrypted_auth_key;
}

void MalwareDetectionServiceImpl::CheckURL(const GURL& url,
                                           CheckUrlCallback callback) {
  VLOG(2) << __func__ << ", url= " << url;

  if (!webrisk_enabled_) {
    VLOG(2) << __func__ << " Failed, WebRisk feature is disabled !!";
    std::move(callback).Run(true);
    return;
  }

  if (initialize_state_ == kInitFailed || initialize_state_ == kInvalidKey) {
    VLOG(2) << __func__ << ", Invalid WebRisk Service Key !!";
    std::move(callback).Run(true);
    return;
  }

  pending_callback_ = std::move(callback);

  malware_detection_thread_.task_runner()->PostTask(
      FROM_HERE,
      base::BindOnce(&MalwareDetectionServiceImpl::CheckURLTask,
                     base::Unretained(this), url));
}

void MalwareDetectionServiceImpl::InitializeTask(
    content::BrowserContext* browser_context) {
  VLOG(2) << __func__;

  webrisk_store_ =
      base::MakeRefCounted<WebRiskStore>(GetFilePath(kWebRiskStoreFileName));

  url_loader_factory_ =
      content::BrowserContext::GetDefaultStoragePartition(browser_context)
          ->GetURLLoaderFactoryForBrowserProcess()
          .get();

  fetch_hashes_request_ = std::make_unique<WebRiskFetchHashes>(
      google_service_auth_key_, webrisk_store_, url_loader_factory_,
      base::Bind(&MalwareDetectionServiceImpl::OnFetchHashResponse,
                     base::Unretained(this)));

  search_hash_request_ = std::make_unique<WebRiskSearchHashes>(
      google_service_auth_key_, url_loader_factory_);

  base::TimeDelta update_time = webrisk_store_->GetFirstUpdateTime();
  fetch_hashes_request_->ScheduleComputeDiffRequest(update_time);
}

void MalwareDetectionServiceImpl::CheckURLTask(const GURL& url) {
  VLOG(2) << __func__ << " initialize_state=" << initialize_state_.load();

  if (initialize_state_ == kInProgress) {
    malware_detection_thread_.task_runner()->PostDelayedTask(
        FROM_HERE,
        base::BindOnce(&MalwareDetectionServiceImpl::CheckURLTask,
                       base::Unretained(this), url),
        base::TimeDelta::FromMilliseconds(kCheckHashUpdateDelayMs));
    return;
  }

  if (initialize_state_ == kInitFailed || initialize_state_ == kInvalidKey) {
    VLOG(2) << __func__ << ", Invalid WebRisk Service Key !!";
    std::move(pending_callback_).Run(true);
    return;
  }

  std::vector<FullHash> full_hashes;
  UrlToFullHashes(url, &full_hashes);
  FindHashPrefix(full_hashes);
}

void MalwareDetectionServiceImpl::FindHashPrefix(
    const std::vector<FullHash>& full_hashes) {
  bool prefix_found = false;
  std::string hash_prefix, prefix_64;
  for (const FullHash full_hash : full_hashes) {
    hash_prefix = full_hash.substr(0, WebRiskStore::kHashPrefixSize);
    base::Base64Encode(hash_prefix, &prefix_64);
    prefix_found = webrisk_store_->IsHashPrefixAvailable(hash_prefix);
    if (prefix_found) {
      search_hash_request_->SearchHashPrefix(
          prefix_64,
          base::BindOnce(&MalwareDetectionServiceImpl::OnSearchHashResponse,
                         base::Unretained(this)));
      return;
    }
  }

  if (pending_callback_ && !prefix_found) {
    VLOG(2) << __func__ << " prefix not found";
    std::move(pending_callback_).Run(true);
  }
}

void MalwareDetectionServiceImpl::OnSearchHashResponse(bool success) {
  VLOG(2) << __func__ << "success = " << success;

  if (pending_callback_)
    std::move(pending_callback_).Run(success);
}

void MalwareDetectionServiceImpl::OnFetchHashResponse(
    WebRiskFetchHashes::Status status) {
  VLOG(2) << __func__ << "status = " << status;

  switch (status) {
    case WebRiskFetchHashes::kSuccess:
      initialize_state_ = kInitialized;
      break;
    case WebRiskFetchHashes::kInvalidKey:
      initialize_state_ = kInvalidKey;
      break;
    case WebRiskFetchHashes::kFailed:
      initialize_state_ = kInitFailed;
      break;
    default:
      break;
  }
}

void MalwareDetectionServiceImpl::UrlToFullHashes(
    const GURL& url,
    std::vector<FullHash>* full_hashes) {
  std::string canon_host, canon_path, canon_query;
  CanonicalizeUrl(url, &canon_host, &canon_path, &canon_query);
  std::vector<std::string> hosts;
  if (url.HostIsIPAddress())
    hosts.push_back(url.host());
  else
    GenerateHostVariantsToCheck(canon_host, &hosts);

  std::vector<std::string> paths;
  GeneratePathVariantsToCheck(canon_path, canon_query, &paths);
  for (const std::string& host : hosts) {
    for (const std::string& path : paths)
      full_hashes->push_back(crypto::SHA256HashString(host + path));
  }
}

bool MalwareDetectionServiceImpl::FullHashToHashPrefix(
    const FullHash& full_hash,
    PrefixSize prefix_size,
    HashPrefix* hash_prefix) {
  if (full_hash.size() < prefix_size)
    return false;

  *hash_prefix = full_hash.substr(0, prefix_size);
  return true;
}

void MalwareDetectionServiceImpl::CanonicalizeUrl(
    const GURL& url,
    std::string* canonicalized_hostname,
    std::string* canonicalized_path,
    std::string* canonicalized_query) {
  DCHECK(url.is_valid());
  // We only canonicalize "normal" URLs.
  if (!url.IsStandard())
    return;

  // Following canonicalization steps are excluded since url parsing takes care
  // of those :-
  // 1. Remove any tab (0x09), CR (0x0d), and LF (0x0a) chars from url.
  //    (Exclude escaped version of these chars).
  // 2. Normalize hostname to 4 dot-seperated decimal values.
  // 3. Lowercase hostname.
  // 4. Resolve path sequences "/../" and "/./".

  // That leaves us with the following :-
  // 1. Remove fragment in URL.
  GURL url_without_fragment;
  GURL::Replacements f_replacements;
  f_replacements.ClearRef();
  f_replacements.ClearUsername();
  f_replacements.ClearPassword();
  url_without_fragment = url.ReplaceComponents(f_replacements);

  // 2. Do URL unescaping until no more hex encoded characters exist.
  std::string url_unescaped_str(Unescape(url_without_fragment.spec()));
  url::Parsed parsed;
  url::ParseStandardURL(url_unescaped_str.data(), url_unescaped_str.length(),
                        &parsed);

  // 3. In hostname, remove all leading and trailing dots.
  base::StringPiece host;
  if (parsed.host.len > 0)
    host = base::StringPiece(url_unescaped_str.data() + parsed.host.begin,
                             parsed.host.len);

  base::StringPiece host_without_end_dots =
      base::TrimString(host, ".", base::TrimPositions::TRIM_ALL);

  // 4. In hostname, replace consecutive dots with a single dot.
  std::string host_without_consecutive_dots(
      RemoveConsecutiveChars(host_without_end_dots, '.'));

  // 5. In path, replace runs of consecutive slashes with a single slash.
  base::StringPiece path;
  if (parsed.path.len > 0)
    path = base::StringPiece(url_unescaped_str.data() + parsed.path.begin,
                             parsed.path.len);
  std::string path_without_consecutive_slash(RemoveConsecutiveChars(path, '/'));

  url::Replacements<char> hp_replacements;
  hp_replacements.SetHost(
      host_without_consecutive_dots.data(),
      url::Component(0, host_without_consecutive_dots.length()));
  hp_replacements.SetPath(
      path_without_consecutive_slash.data(),
      url::Component(0, path_without_consecutive_slash.length()));

  std::string url_unescaped_with_can_hostpath;
  url::StdStringCanonOutput output(&url_unescaped_with_can_hostpath);
  url::Parsed temp_parsed;
  url::ReplaceComponents(url_unescaped_str.data(), url_unescaped_str.length(),
                         parsed, hp_replacements, nullptr, &output,
                         &temp_parsed);
  output.Complete();

  // 6. Step needed to revert escaping done in url::ReplaceComponents.
  url_unescaped_with_can_hostpath = Unescape(url_unescaped_with_can_hostpath);

  // 7. After performing all above steps, percent-escape all chars in url which
  // are <= ASCII 32, >= 127, #, %. Escapes must be uppercase hex characters.
  std::string escaped_canon_url_str(Escape(url_unescaped_with_can_hostpath));
  url::Parsed final_parsed;
  url::ParseStandardURL(escaped_canon_url_str.data(),
                        escaped_canon_url_str.length(), &final_parsed);

  if (canonicalized_hostname && final_parsed.host.len > 0) {
    *canonicalized_hostname = escaped_canon_url_str.substr(
        final_parsed.host.begin, final_parsed.host.len);
  }

  if (canonicalized_path && final_parsed.path.len > 0) {
    *canonicalized_path = escaped_canon_url_str.substr(final_parsed.path.begin,
                                                       final_parsed.path.len);
  }

  if (canonicalized_query && final_parsed.query.len > 0) {
    *canonicalized_query = escaped_canon_url_str.substr(
        final_parsed.query.begin, final_parsed.query.len);
  }
}

}  // namespace webrisk
